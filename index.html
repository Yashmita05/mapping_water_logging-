<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Delhi Waterlogging Hotspots - Heatmap with Legend</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    h2 { text-align: center; margin: 10px; }
    #map { height: 85vh; width: 100%; }
    #controls { text-align: center; margin-bottom: 10px; }
    .legend {
      background: white;
      line-height: 1.5em;
      padding: 6px 8px;
      color: #555;
      border-radius: 5px;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
    }
    .legend-title { font-weight: bold; margin-bottom: 5px; }
    .legend-item { display: flex; align-items: center; }
    .legend-color { width: 18px; height: 18px; margin-right: 6px; border: 1px solid #999; }
  </style>
</head>

<body>
<h2>Delhi Water-Logging Hotspots with Real-Time Rainfall</h2>

<div id="controls">
  <label><b>Rainfall Scenario (mm):</b></label>
  <select id="rainfall">
    <option value="20">Light Rain (20 mm)</option>
    <option value="50">Moderate Rain (50 mm)</option>
    <option value="100">Heavy Rain (100 mm)</option>
    <option value="real">Use Real-Time Rainfall</option>
  </select>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

<script>
// ---------------- MAP ----------------
const map = L.map("map").setView([28.6139, 77.2090], 11);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "© OpenStreetMap contributors",
}).addTo(map);

const hotspotLayer = L.layerGroup().addTo(map);

let markers = [];
let heatLayer;

// ---------------- RULE-BASED FUNCTIONS ----------------
function getRecurrenceWeight(level) {
  if (level === "High") return 3;
  if (level === "Medium") return 2;
  return 1;
}
function getTypeWeight(type) {
  if (type.includes("Underpass")) return 3;
  if (type.includes("Flyover")) return 2;
  return 1;
}
function getRainfallWeight(mm) {
  if (mm > 80) return 3;
  if (mm >= 40) return 2;
  return 1;
}
function getColor(score) {
  if (score >= 8) return "red";
  if (score >= 6) return "orange";
  return "green";
}

// ---------------- ML HEATMAP HELPER ----------------
function mlPriorityToHeat(priority) {
  const p = parseFloat(priority);
  if (isNaN(p)) return 0.2;
  return Math.min(p / 100, 1);
}

// ---------------- LOAD ML CSV ----------------
let mlDataMap = {};
Papa.parse("govt_flood_action_plan.csv", {
  download: true,
  header: true,
  complete: function(results) {
    results.data.forEach(row => {
      if (row.location) {
        mlDataMap[row.location.trim().toLowerCase()] = row;
      }
    });
    console.log("ML data loaded");
  }
});

function clearMarkers() {
  markers.forEach(m => map.removeLayer(m));
  markers = [];
  if (heatLayer) map.removeLayer(heatLayer);
}

// ---------------- MAIN PLOTTING ----------------
function plotMarkersAndHeat(rainfall_mm) {
  Papa.parse("hotspots.csv", {
    download: true,
    header: true,
    complete: function(results) {
      const heatData = [];

      results.data.forEach(row => {
        if (!row.latitude || !row.longitude) return;

        // RULE-BASED MARKERS
        const score =
          getRecurrenceWeight(row.recurrence_level) +
          getTypeWeight(row.hotspot_type) +
          getRainfallWeight(rainfall_mm);

        const color = getColor(score);

        const marker = L.circleMarker([row.latitude, row.longitude], {
          radius: 8,
          color: color,
          fillColor: color,
          fillOpacity: 0.8
        }).addTo(map);

        // ML POPUP
        const locKey = row.location.trim().toLowerCase();
        const ml = mlDataMap[locKey];

        const mlHtml = ml ? `
          <hr/>
          <b>ML Predicted Flood Risk:</b> ${ml.predicted_flood_risk}<br/>
          <b>Priority Score:</b> ${ml.priority_score}<br/>
          <b>Recommended Action:</b><br/>
          ${ml.recommended_action}
        ` : `<hr/><i>ML prediction not available</i>`;

        marker.bindPopup(`
          <b>${row.location}</b><br/>
          <b>Zone/Area:</b> ${row.area}<br/>
          <b>Type:</b> ${row.hotspot_type}<br/>
          <b>Recurrence:</b> ${row.recurrence_level}<br/>
          <b>Rainfall Used:</b> ${rainfall_mm} mm
          ${mlHtml}
        `);

        markers.push(marker);

        // ML-BASED HEATMAP
        let heatValue = 0.2;
        if (ml && ml.priority_score) {
          heatValue = mlPriorityToHeat(ml.priority_score);
        }

        heatData.push([
          parseFloat(row.latitude),
          parseFloat(row.longitude),
          heatValue
        ]);
      });

      heatLayer = L.heatLayer(heatData, {
        radius: 25,
        blur: 15,
        maxZoom: 17
      }).addTo(map);
    }
  });
}

// ---------------- RAINFALL HANDLING ----------------
function loadHotspots(val) {
  clearMarkers();
  if (val === "real") {
    fetch("https://api.weatherapi.com/v1/current.json?key=YOUR_API_KEY&q=28.6139,77.2090")
      .then(r => r.json())
      .then(d => plotMarkersAndHeat(d.current.precip_mm))
      .catch(() => plotMarkersAndHeat(20));
  } else {
    plotMarkersAndHeat(parseFloat(val));
  }
}

loadHotspots(20);
document.getElementById("rainfall").addEventListener("change", e => loadHotspots(e.target.value));

// ---------------- LEGEND ----------------
const legend = L.control({ position: 'bottomright' });
legend.onAdd = function () {
  const div = L.DomUtil.create('div', 'legend');
  div.innerHTML += '<div class="legend-title">Risk Score / Heatmap</div>';
  div.innerHTML += '<div class="legend-item"><div class="legend-color" style="background:red"></div>High Risk</div>';
  div.innerHTML += '<div class="legend-item"><div class="legend-color" style="background:orange"></div>Medium Risk</div>';
  div.innerHTML += '<div class="legend-item"><div class="legend-color" style="background:green"></div>Low Risk</div>';
  div.innerHTML += '<div style="margin-top:5px;font-size:12px;">Heat intensity ∝ ML priority score</div>';
  return div;
};
legend.addTo(map);
 /// ===============================
  // DRAINAGE INFORMATION LAYER
  // ===============================

  const drainageLayer = L.layerGroup();

  function getDrainageColor(quality) {
    if (quality === "Poor") return "#b30000";        // dark red
    if (quality === "Moderate") return "#ff8c00";    // orange
    return "#2e8b57";                                // green
  }

  // Load drainage data
  Papa.parse("delhi_drainage_dummy_dataset.csv", {
    download: true,
    header: true,
    complete: function(drainageData) {

      // Load hotspots to reuse coordinates
      Papa.parse("hotspots.csv", {
        download: true,
        header: true,
        complete: function(hotspotData) {

          drainageData.data.forEach((drain, index) => {
            if (!hotspotData.data[index]) return;

            const lat = hotspotData.data[index].latitude;
            const lon = hotspotData.data[index].longitude;
            if (!lat || !lon) return;

            const color = getDrainageColor(drain.drainage_quality);

            const marker = L.circleMarker([lat, lon], {
              radius: 7,
              color: color,
              fillColor: color,
              fillOpacity: 0.75
            });

            marker.bindPopup(`
              <b>Drainage Information</b><br/><br/>
              <b>Location:</b> ${drain.location}<br/>
              <b>Drainage Basin:</b> ${drain.dominant_basin}<br/>
              <b>Drain Type:</b> ${drain.dominant_drain_type}<br/>
              <b>Drain Length:</b> ${drain.approx_drain_length_m} m<br/>
              <b>Manholes:</b> ${drain.estimated_manhole_count}<br/>
              <b>Drainage Quality:</b> ${drain.drainage_quality}<br/>
              <b>Sewage Mixing Risk:</b> ${drain.sewage_mixing_risk}<br/>
              <b>Flooding Frequency:</b> ${drain.flooding_frequency}<br/>
              <b>Main Issues:</b> ${drain.main_issues}
            `);

            drainageLayer.addLayer(marker);
          });

        }
      });

    }
  });

  // ===============================
  // LAYER CONTROL
  // ===============================

  const overlays = {
    "Waterlogging Hotspots": map,
    "Drainage Information": drainageLayer
  };

  L.control.layers(null, overlays, { collapsed: false }).addTo(map);
</script>
</body>
</html>
