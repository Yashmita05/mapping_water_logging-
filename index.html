<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Delhi Waterlogging Hotspots - Heatmap with Legend</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    h2 { text-align: center; margin: 10px; }
    #map { height: 85vh; width: 100%; }
    #controls { text-align: center; margin-bottom: 10px; }
    .legend {
      background: white;
      line-height: 1.5em;
      padding: 6px 8px;
      color: #555;
      border-radius: 5px;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
    }
    .legend-title { font-weight: bold; margin-bottom: 5px; }
    .legend-item { display: flex; align-items: center; }
    .legend-color { width: 18px; height: 18px; margin-right: 6px; border: 1px solid #999; }
  </style>
</head>

<body>
  <h2>Delhi Water-Logging Hotspots with Real-Time Rainfall</h2>

  <div id="controls">
    <label><b>Rainfall Scenario (mm):</b></label>
    <select id="rainfall">
      <option value="20">Light Rain (20 mm)</option>
      <option value="50">Moderate Rain (50 mm)</option>
      <option value="100">Heavy Rain (100 mm)</option>
      <option value="real">Use Real-Time Rainfall</option>
    </select>
  </div>

  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

  <script>
    const map = L.map("map").setView([28.6139, 77.2090], 11);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "© OpenStreetMap contributors",
    }).addTo(map);

    let markers = [];
    let heatLayer;

    const apiKey = "2f0d3b1672b24e7d99e133318253012"; // WeatherAPI key
    const lat = 28.6139;
    const lon = 77.2090;

    function getRecurrenceWeight(level) {
      if (level === "High") return 3;
      if (level === "Medium") return 2;
      return 1;
    }
    function getTypeWeight(type) {
      if (type.includes("Underpass")) return 3;
      if (type.includes("Flyover")) return 2;
      return 1;
    }
    function getRainfallWeight(mm) {
      if (mm > 80) return 3;
      if (mm >= 40) return 2;
      return 1;
    }
    function getColor(score) {
      if (score >= 8) return "red";
      if (score >= 6) return "orange";
      return "green";
    }

    function clearMarkers() {
      markers.forEach(m => map.removeLayer(m));
      markers = [];
      if (heatLayer) map.removeLayer(heatLayer);
    }

    function plotMarkersAndHeat(rainfall_mm) {
      Papa.parse("hotspots.csv", {
        download: true,
        header: true,
        complete: function(results) {
          const heatData = [];

          results.data.forEach(row => {
            if (!row.latitude || !row.longitude) return;

            const score = getRecurrenceWeight(row.recurrence_level) +
                          getTypeWeight(row.hotspot_type) +
                          getRainfallWeight(rainfall_mm);
            const color = getColor(score);

            const marker = L.circleMarker([row.latitude, row.longitude], {
              radius: 8,
              color: color,
              fillColor: color,
              fillOpacity: 0.8
            }).addTo(map);

marker.bindPopup(`
  <b>${row.location}</b><br/>
  <b>Zone/Area:</b> ${row.area}<br/>
  <b>Type:</b> ${row.hotspot_type}<br/>
  <b>Recurrence:</b> ${row.recurrence_level}<br/>
  <b>Predicted Risk Score:</b> ${score}<br/>
  <b>Rainfall Used:</b> ${rainfall_mm} mm
`);


            markers.push(marker);
            heatData.push([parseFloat(row.latitude), parseFloat(row.longitude), score / 9]);
          });

          heatLayer = L.heatLayer(heatData, {radius: 25, blur: 15, maxZoom: 17}).addTo(map);
        }
      });
    }

    function loadHotspots(rainfallValue) {
      clearMarkers();

      if (rainfallValue === "real") {
        fetch(`https://api.weatherapi.com/v1/current.json?key=${apiKey}&q=${lat},${lon}`)
          .then(res => res.json())
          .then(data => {
            const realRain = data.current.precip_mm;
            plotMarkersAndHeat(realRain);
          })
          .catch(err => {
            alert("Could not fetch real-time rainfall. Using 20 mm default.");
            plotMarkersAndHeat(20);
          });
      } else {
        plotMarkersAndHeat(parseFloat(rainfallValue));
      }
    }

    // --- Initial Load ---
    loadHotspots(20);

    document.getElementById("rainfall").addEventListener("change", function() {
      loadHotspots(this.value);
    });

    // --- Auto-refresh real-time rainfall every 10 minutes ---
    setInterval(() => {
      const dropdown = document.getElementById("rainfall");
      if (dropdown.value === "real") loadHotspots("real");
    }, 10 * 60 * 1000);

    // --- Add Legend ---
    const legend = L.control({position: 'bottomright'});
    legend.onAdd = function(map) {
      const div = L.DomUtil.create('div', 'legend');
      div.innerHTML += '<div class="legend-title">Risk Score / Heatmap</div>';
      div.innerHTML += '<div class="legend-item"><div class="legend-color" style="background:red"></div>High Risk (Score 8-9)</div>';
      div.innerHTML += '<div class="legend-item"><div class="legend-color" style="background:orange"></div>Medium Risk (Score 6-7)</div>';
      div.innerHTML += '<div class="legend-item"><div class="legend-color" style="background:green"></div>Low Risk (Score ≤5)</div>';
      div.innerHTML += '<div style="margin-top:5px;font-size:12px;">Heat intensity proportional to predicted risk</div>';
      return div;
    };
    legend.addTo(map);

    // ===============================
  // DRAINAGE INFORMATION LAYER
  // ===============================

  const drainageLayer = L.layerGroup();

  function getDrainageColor(quality) {
    if (quality === "Poor") return "#b30000";        // dark red
    if (quality === "Moderate") return "#ff8c00";    // orange
    return "#2e8b57";                                // green
  }

  // Load drainage data
  Papa.parse("delhi_drainage_dummy_dataset.csv", {
    download: true,
    header: true,
    complete: function(drainageData) {

      // Load hotspots to reuse coordinates
      Papa.parse("hotspots.csv", {
        download: true,
        header: true,
        complete: function(hotspotData) {

          drainageData.data.forEach((drain, index) => {
            if (!hotspotData.data[index]) return;

            const lat = hotspotData.data[index].latitude;
            const lon = hotspotData.data[index].longitude;
            if (!lat || !lon) return;

            const color = getDrainageColor(drain.drainage_quality);

            const marker = L.circleMarker([lat, lon], {
              radius: 7,
              color: color,
              fillColor: color,
              fillOpacity: 0.75
            });

            marker.bindPopup(`
              <b>Drainage Information</b><br/><br/>
              <b>Location:</b> ${drain.location}<br/>
              <b>Drainage Basin:</b> ${drain.dominant_basin}<br/>
              <b>Drain Type:</b> ${drain.dominant_drain_type}<br/>
              <b>Drain Length:</b> ${drain.approx_drain_length_m} m<br/>
              <b>Manholes:</b> ${drain.estimated_manhole_count}<br/>
              <b>Drainage Quality:</b> ${drain.drainage_quality}<br/>
              <b>Sewage Mixing Risk:</b> ${drain.sewage_mixing_risk}<br/>
              <b>Flooding Frequency:</b> ${drain.flooding_frequency}<br/>
              <b>Main Issues:</b> ${drain.main_issues}
            `);

            drainageLayer.addLayer(marker);
          });

        }
      });

    }
  });

  // ===============================
  // LAYER CONTROL
  // ===============================

  const overlays = {
    "Waterlogging Hotspots": map,
    "Drainage Information": drainageLayer
  };

  L.control.layers(null, overlays, { collapsed: false }).addTo(map);

  </script>
</body>
</html>

