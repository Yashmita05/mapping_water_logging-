# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rKPXBB3mcTTkqG_Sjc3owrEFow1XZGUK
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix

# Load dataset
drainage = pd.read_csv("delhi_drainage_dummy_dataset.csv")
rainfall = pd.read_csv("delhi_rainfall_features.csv")

df = drainage.merge(rainfall, on="location", how="inner")


# Target
y = df["flooding_frequency"]

# Features
X = df.drop(columns=["flooding_frequency", "location"])

# Identify column types
categorical_cols = [
    "dominant_basin",
    "dominant_drain_type",
    "drainage_quality",
    "sewage_mixing_risk"
]

numeric_cols = [
    "approx_drain_length_m",
    "estimated_manhole_count",
    "avg_rainfall_mm",
    "max_24hr_rainfall_mm",
    "consecutive_rain_days",
    "extreme_rain_event"
]

# Preprocessing
preprocessor = ColumnTransformer(
    transformers=[
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_cols),
        ("num", "passthrough", numeric_cols)
    ]
)

# Model
model = RandomForestClassifier(
    n_estimators=300,
    max_depth=12,
    random_state=42,
    class_weight="balanced"
)

# Pipeline
pipeline = Pipeline(steps=[
    ("preprocessing", preprocessor),
    ("model", model)
])

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.25, random_state=42, stratify=y
)

# Train
pipeline.fit(X_train, y_train)

# Evaluate
y_pred = pipeline.predict(X_test)

print(classification_report(y_test, y_pred))
print(confusion_matrix(y_test, y_pred))

# Predict flood risk for all locations
df["predicted_flood_risk"] = pipeline.predict(X)

# Save predictions
df[["location", "predicted_flood_risk"]].to_csv(
    "flood_risk_predictions.csv", index=False
)

df[["location", "predicted_flood_risk"]].head()

# Rule-based government action engine
def govt_action(risk):
    if risk == "High":
        return "Immediate drain desilting, deploy pumps, emergency response team on standby"
    elif risk == "Medium":
        return "Preventive drain inspection and cleaning within 7 days"
    else:
        return "Routine monitoring; no immediate action required"

df["recommended_action"] = df["predicted_flood_risk"].apply(govt_action)

# Rule-based government action engine
def govt_action(risk):
    if risk == "High":
        return "Immediate drain desilting, deploy pumps, emergency response team on standby"
    elif risk == "Medium":
        return "Preventive drain inspection and cleaning within 7 days"
    else:
        return "Routine monitoring; no immediate action required"

df["recommended_action"] = df["predicted_flood_risk"].apply(govt_action)

# Create priority score from predicted risk
risk_score_map = {
    "Low": 30,
    "Medium": 60,
    "High": 90
}

df["priority_score"] = df["predicted_flood_risk"].map(risk_score_map)

df_final = df[
    [
        "location",
        "predicted_flood_risk",
        "priority_score",
        "recommended_action"
    ]
]

df_final.to_csv("govt_flood_action_plan.csv", index=False)

df_final.head()